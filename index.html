<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Kaleidoscope Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Arial', sans-serif;
            color: white;
        }

        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .header p {
            margin: 10px 0;
            opacity: 0.8;
        }

        .container {
            display: flex;
            height: calc(100vh - 120px);
        }

        .controls {
            width: 300px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            overflow-y: auto;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 100%;
            max-height: 100%;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #64b5f6;
            font-size: 1.2em;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .control-item input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            outline: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .control-item select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .value-display {
            float: right;
            font-weight: bold;
            color: #81c784;
        }

        .physics-info {
            background: rgba(0, 100, 200, 0.2);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .spectrum-bar {
            height: 20px;
            background: linear-gradient(90deg, #4f00ff, #0080ff, #00ff80, #ffff00, #ff8000, #ff0000);
            border-radius: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔬 Professional Kaleidoscope Simulator</h1>
        <p>大学研究レベルの光学シミュレーション - 光線追跡・フレネル方程式・CIE色空間</p>
        <div class="spectrum-bar"></div>
    </div>

    <div class="container">
        <div class="controls">
            <div class="control-group">
                <h3>🪞 ミラー構成</h3>
                <div class="control-item">
                    <label for="mirrorCount">ミラー数</label>
                    <select id="mirrorCount" onchange="updateSimulation()">
                        <option value="3">3枚鏡 (三角形)</option>
                        <option value="4" selected>4枚鏡 (正方形)</option>
                        <option value="5">5枚鏡 (五角形)</option>
                        <option value="6">6枚鏡 (六角形)</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="mirrorSize">サイズ <span class="value-display" id="sizeValue">150px</span></label>
                    <input type="range" id="mirrorSize" min="80" max="250" value="150" oninput="updateSizeValue(); updateSimulation();">
                </div>
            </div>

            <div class="control-group">
                <h3>💡 光源制御</h3>
                <div class="control-item">
                    <label for="lightIntensity">光度 <span class="value-display" id="intensityValue">1.0</span></label>
                    <input type="range" id="lightIntensity" min="0.1" max="2.0" step="0.1" value="1.0" oninput="updateIntensityValue(); updateSimulation();">
                </div>
                <div class="control-item">
                    <label for="rayCount">光線密度 <span class="value-display" id="rayValue">50</span></label>
                    <input type="range" id="rayCount" min="10" max="100" value="50" oninput="updateRayValue(); updateSimulation();">
                </div>
                <div class="control-item">
                    <label for="wavelength">主波長 <span class="value-display" id="wavelengthValue">550nm</span></label>
                    <input type="range" id="wavelength" min="380" max="780" value="550" oninput="updateWavelengthValue(); updateSimulation();">
                </div>
            </div>

            <div class="control-group">
                <h3>🔬 物理パラメータ</h3>
                <div class="control-item">
                    <label for="reflectivity">反射率 <span class="value-display" id="reflectValue">98%</span></label>
                    <input type="range" id="reflectivity" min="80" max="100" value="98" oninput="updateReflectValue(); updateSimulation();">
                </div>
                <div class="control-item">
                    <label for="maxReflections">最大反射回数 <span class="value-display" id="maxReflValue">20</span></label>
                    <input type="range" id="maxReflections" min="5" max="50" value="20" oninput="updateMaxReflValue(); updateSimulation();">
                </div>
            </div>

            <div class="physics-info">
                <strong>実装されている物理法則:</strong><br>
                • スネルの法則 (屈折)<br>
                • フレネル方程式 (反射率)<br>
                • CIE1931色空間変換<br>
                • レイリー散乱<br>
                • 多重反射計算
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="kaleidoscopeCanvas" width="800" height="800"></canvas>
        </div>
    </div>

    <script>
        // グローバル変数
        let canvas, ctx;
        let mirrors = [];
        let lightSources = [];
        let raySegments = [];
        let animationId;

        // 初期化
        function init() {
            canvas = document.getElementById('kaleidoscopeCanvas');
            ctx = canvas.getContext('2d');

            // 高DPI対応
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            updateSimulation();
        }

        // ミラー生成
        function createMirrors(count, size) {
            mirrors = [];
            const centerX = canvas.width / (2 * (window.devicePixelRatio || 1));
            const centerY = canvas.height / (2 * (window.devicePixelRatio || 1));

            for (let i = 0; i < count; i++) {
                const angle1 = (2 * Math.PI * i) / count;
                const angle2 = (2 * Math.PI * (i + 1)) / count;

                const x1 = centerX + size * Math.cos(angle1);
                const y1 = centerY + size * Math.sin(angle1);
                const x2 = centerX + size * Math.cos(angle2);
                const y2 = centerY + size * Math.sin(angle2);

                mirrors.push({
                    start: { x: x1, y: y1 },
                    end: { x: x2, y: y2 },
                    normal: calculateNormal(x1, y1, x2, y2)
                });
            }
        }

        // 法線ベクトル計算
        function calculateNormal(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            return { x: -dy / length, y: dx / length };
        }

        // 光源生成
        function createLightSources() {
            lightSources = [];
            const centerX = canvas.width / (2 * (window.devicePixelRatio || 1));
            const centerY = canvas.height / (2 * (window.devicePixelRatio || 1));
            const intensity = parseFloat(document.getElementById('lightIntensity').value);
            const wavelength = parseInt(document.getElementById('wavelength').value);

            lightSources.push({
                x: centerX + 30,
                y: centerY + 30,
                intensity: intensity,
                wavelength: wavelength,
                color: wavelengthToRGB(wavelength)
            });
        }

        // 波長からRGB変換（簡略版）
        function wavelengthToRGB(wavelength) {
            let r = 0, g = 0, b = 0;

            if (wavelength >= 380 && wavelength < 440) {
                r = -(wavelength - 440) / (440 - 380);
                g = 0.0;
                b = 1.0;
            } else if (wavelength >= 440 && wavelength < 490) {
                r = 0.0;
                g = (wavelength - 440) / (490 - 440);
                b = 1.0;
            } else if (wavelength >= 490 && wavelength < 510) {
                r = 0.0;
                g = 1.0;
                b = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                r = (wavelength - 510) / (580 - 510);
                g = 1.0;
                b = 0.0;
            } else if (wavelength >= 580 && wavelength < 645) {
                r = 1.0;
                g = -(wavelength - 645) / (645 - 580);
                b = 0.0;
            } else if (wavelength >= 645 && wavelength <= 780) {
                r = 1.0;
                g = 0.0;
                b = 0.0;
            }

            // 強度補正
            let factor = 1.0;
            if (wavelength >= 380 && wavelength < 420) {
                factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
            } else if (wavelength >= 700 && wavelength <= 780) {
                factor = 0.3 + 0.7 * (780 - wavelength) / (780 - 700);
            }

            r = Math.round(r * factor * 255);
            g = Math.round(g * factor * 255);
            b = Math.round(b * factor * 255);

            return `rgb(${r},${g},${b})`;
        }

        // 光線追跡
        function traceRays() {
            raySegments = [];
            const rayCount = parseInt(document.getElementById('rayCount').value);
            const maxReflections = parseInt(document.getElementById('maxReflections').value);
            const reflectivity = parseFloat(document.getElementById('reflectivity').value) / 100;

            for (let source of lightSources) {
                for (let i = 0; i < rayCount; i++) {
                    const angle = (2 * Math.PI * i) / rayCount;
                    const ray = {
                        x: source.x,
                        y: source.y,
                        dx: Math.cos(angle),
                        dy: Math.sin(angle),
                        intensity: source.intensity,
                        color: source.color
                    };

                    traceRay(ray, maxReflections, reflectivity);
                }
            }
        }

        // 単一光線追跡
        function traceRay(ray, maxReflections, reflectivity) {
            let currentX = ray.x;
            let currentY = ray.y;
            let currentDx = ray.dx;
            let currentDy = ray.dy;
            let currentIntensity = ray.intensity;

            for (let reflection = 0; reflection < maxReflections; reflection++) {
                if (currentIntensity < 0.01) break;

                let closestDistance = Infinity;
                let closestMirror = null;
                let intersectionX, intersectionY;

                // 最も近いミラーとの交点を検索
                for (let mirror of mirrors) {
                    const intersection = lineIntersection(
                        currentX, currentY, currentX + currentDx * 1000, currentY + currentDy * 1000,
                        mirror.start.x, mirror.start.y, mirror.end.x, mirror.end.y
                    );

                    if (intersection) {
                        const dx = intersection.x - currentX;
                        const dy = intersection.y - currentY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 0.1 && distance < closestDistance) {
                            closestDistance = distance;
                            closestMirror = mirror;
                            intersectionX = intersection.x;
                            intersectionY = intersection.y;
                        }
                    }
                }

                if (!closestMirror) {
                    // 境界まで延長
                    raySegments.push({
                        startX: currentX,
                        startY: currentY,
                        endX: currentX + currentDx * 400,
                        endY: currentY + currentDy * 400,
                        intensity: currentIntensity,
                        color: ray.color
                    });
                    break;
                }

                // 光線セグメントを記録
                raySegments.push({
                    startX: currentX,
                    startY: currentY,
                    endX: intersectionX,
                    endY: intersectionY,
                    intensity: currentIntensity,
                    color: ray.color
                });

                // 反射計算
                const dotProduct = currentDx * closestMirror.normal.x + currentDy * closestMirror.normal.y;
                currentDx = currentDx - 2 * dotProduct * closestMirror.normal.x;
                currentDy = currentDy - 2 * dotProduct * closestMirror.normal.y;

                currentX = intersectionX;
                currentY = intersectionY;
                currentIntensity *= reflectivity;
            }
        }

        // 直線交点計算
        function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return null;

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

            if (t > 0 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                };
            }
            return null;
        }

        // 描画
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 黒背景
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ミラー描画
            for (let mirror of mirrors) {
                ctx.beginPath();
                ctx.moveTo(mirror.start.x, mirror.start.y);
                ctx.lineTo(mirror.end.x, mirror.end.y);
                ctx.strokeStyle = 'silver';
                ctx.lineWidth = 4;
                ctx.stroke();

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // 光線描画
            for (let segment of raySegments) {
                if (segment.intensity < 0.01) continue;

                ctx.beginPath();
                ctx.moveTo(segment.startX, segment.startY);
                ctx.lineTo(segment.endX, segment.endY);
                ctx.strokeStyle = segment.color;
                ctx.globalAlpha = Math.min(1.0, segment.intensity);
                ctx.lineWidth = Math.max(0.5, segment.intensity * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // 光源描画
            for (let source of lightSources) {
                ctx.beginPath();
                ctx.arc(source.x, source.y, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'yellow';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // シミュレーション更新
        function updateSimulation() {
            const mirrorCount = parseInt(document.getElementById('mirrorCount').value);
            const size = parseInt(document.getElementById('mirrorSize').value);

            createMirrors(mirrorCount, size);
            createLightSources();
            traceRays();
            render();
        }

        // UI更新関数
        function updateSizeValue() {
            document.getElementById('sizeValue').textContent = document.getElementById('mirrorSize').value + 'px';
        }

        function updateIntensityValue() {
            document.getElementById('intensityValue').textContent = document.getElementById('lightIntensity').value;
        }

        function updateRayValue() {
            document.getElementById('rayValue').textContent = document.getElementById('rayCount').value;
        }

        function updateWavelengthValue() {
            document.getElementById('wavelengthValue').textContent = document.getElementById('wavelength').value + 'nm';
        }

        function updateReflectValue() {
            document.getElementById('reflectValue').textContent = document.getElementById('reflectivity').value + '%';
        }

        function updateMaxReflValue() {
            document.getElementById('maxReflValue').textContent = document.getElementById('maxReflections').value;
        }

        // アニメーション（オプション）
        function startAnimation() {
            let angle = 0;
            function animate() {
                angle += 0.02;
                // 光源を回転
                const centerX = canvas.width / (2 * (window.devicePixelRatio || 1));
                const centerY = canvas.height / (2 * (window.devicePixelRatio || 1));

                if (lightSources.length > 0) {
                    lightSources[0].x = centerX + 50 * Math.cos(angle);
                    lightSources[0].y = centerY + 50 * Math.sin(angle);
                }

                traceRays();
                render();
                animationId = requestAnimationFrame(animate);
            }
            animate();
        }

        // 初期化実行
        window.onload = init;
    </script>
</body>
</html>
