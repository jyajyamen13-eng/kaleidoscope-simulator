<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>万華鏡シミュレーター Pro - 完全版</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        .kaleidoscope-container {
            background: radial-gradient(circle, #1a202c 0%, #0f1419 100%);
        }
        .control-panel {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 1px solid #4a5568;
        }
        .slider {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #4a5568;
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
            border: 2px solid #2b6cb0;
        }
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
            border: 2px solid #2b6cb0;
        }
        .preset-btn {
            transition: all 0.3s ease;
        }
        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 179, 237, 0.3);
        }
        .mirror-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 4px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                万華鏡シミュレーター Pro
            </h1>
            <p class="text-gray-400">光学理論に基づく高度な万華鏡体験 - 専門エージェント統合版</p>
        </header>

        <div class="grid lg:grid-cols-4 gap-6">
            <!-- Control Panel -->
            <div class="lg:col-span-1">
                <div class="control-panel rounded-lg p-4 space-y-4">
                    <!-- Mirror Configuration -->
                    <div>
                        <h3 class="text-lg font-semibold mb-3 flex items-center">
                            <i class="fas fa-mirror mr-2"></i>ミラー設定
                        </h3>
                        
                        <div class="mb-4">
                            <label class="block text-sm font-medium mb-2">ミラー数</label>
                            <select id="mirrorCount" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white">
                                <option value="2">2枚鏡 (クラシック)</option>
                                <option value="3" selected>3枚鏡 (三角室)</option>
                                <option value="4">4枚鏡 (正方形)</option>
                                <option value="6">6枚鏡 (六角形)</option>
                                <option value="8">8枚鏡 (八角形)</option>
                            </select>
                        </div>

                        <div id="angleControls" class="space-y-3">
                            <!-- Dynamic angle controls -->
                        </div>
                    </div>

                    <!-- Material Properties -->
                    <div>
                        <h3 class="text-lg font-semibold mb-3 flex items-center">
                            <i class="fas fa-atom mr-2"></i>材質設定
                        </h3>
                        
                        <div class="mb-3">
                            <label class="block text-sm font-medium mb-2">材質プリセット</label>
                            <select id="materialPreset" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white">
                                <option value="silver">銀鏡 (R=0.975)</option>
                                <option value="aluminum" selected>アルミ (R=0.90)</option>
                                <option value="plastic">プラスチック (R=0.85)</option>
                                <option value="custom">カスタム</option>
                            </select>
                        </div>

                        <div class="mb-3">
                            <label class="block text-sm font-medium mb-2">
                                反射率: <span id="reflectanceValue">0.90</span>
                            </label>
                            <input type="range" id="reflectance" class="slider w-full" min="0.70" max="0.995" step="0.005" value="0.90">
                        </div>

                        <div class="mb-3">
                            <label class="block text-sm font-medium mb-2">
                                表面粗さ: <span id="roughnessValue">0.02</span>
                            </label>
                            <input type="range" id="roughness" class="slider w-full" min="0.01" max="0.1" step="0.01" value="0.02">
                        </div>
                    </div>

                    <!-- Physics Settings -->
                    <div>
                        <h3 class="text-lg font-semibold mb-3 flex items-center">
                            <i class="fas fa-flask mr-2"></i>物理設定
                        </h3>
                        
                        <div class="mb-3">
                            <label class="flex items-center cursor-pointer">
                                <input type="checkbox" id="wetMode" class="mr-2">
                                <span>ウェット（液体）モード</span>
                            </label>
                        </div>

                        <div class="mb-3">
                            <label class="block text-sm font-medium mb-2">
                                オブジェクト数: <span id="objectCountValue">80</span>
                            </label>
                            <input type="range" id="objectCount" class="slider w-full" min="20" max="200" step="10" value="80">
                        </div>

                        <div class="mb-3">
                            <label class="block text-sm font-medium mb-2">
                                動作速度: <span id="speedValue">1.0</span>x
                            </label>
                            <input type="range" id="speed" class="slider w-full" min="0.1" max="3.0" step="0.1" value="1.0">
                        </div>

                        <div class="mb-3" id="viscosityControl" style="display: none;">
                            <label class="block text-sm font-medium mb-2">
                                粘性: <span id="viscosityValue">0.1</span>
                            </label>
                            <input type="range" id="viscosity" class="slider w-full" min="0.01" max="0.5" step="0.01" value="0.1">
                        </div>
                    </div>

                    <!-- Optical Effects -->
                    <div>
                        <h3 class="text-lg font-semibold mb-3 flex items-center">
                            <i class="fas fa-eye mr-2"></i>光学効果
                        </h3>
                        
                        <div class="mb-3">
                            <label class="flex items-center cursor-pointer">
                                <input type="checkbox" id="polarization" class="mr-2">
                                <span>偏光効果</span>
                            </label>
                        </div>

                        <div class="mb-3" id="polarizationControls" style="display: none;">
                            <label class="block text-sm font-medium mb-2">
                                偏光角度: <span id="polarAngleValue">0</span>°
                            </label>
                            <input type="range" id="polarAngle" class="slider w-full" min="0" max="180" step="5" value="0">
                        </div>

                        <div class="mb-3">
                            <label class="flex items-center cursor-pointer">
                                <input type="checkbox" id="dispersion" class="mr-2">
                                <span>分散効果</span>
                            </label>
                        </div>
                    </div>

                    <!-- Presets -->
                    <div>
                        <h3 class="text-lg font-semibold mb-3 flex items-center">
                            <i class="fas fa-bookmark mr-2"></i>プリセット
                        </h3>
                        
                        <div class="grid grid-cols-2 gap-2">
                            <button class="preset-btn bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded text-sm" data-preset="hexagon">
                                六角形
                            </button>
                            <button class="preset-btn bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-sm" data-preset="square">
                                正方形
                            </button>
                            <button class="preset-btn bg-green-600 hover:bg-green-700 px-3 py-2 rounded text-sm" data-preset="kaleidoscope">
                                万華鏡
                            </button>
                            <button class="preset-btn bg-red-600 hover:bg-red-700 px-3 py-2 rounded text-sm" data-preset="organic">
                                オーガニック
                            </button>
                        </div>
                    </div>

                    <!-- Controls -->
                    <div class="pt-4 border-t border-gray-600">
                        <div class="flex space-x-2">
                            <button id="pauseBtn" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded flex-1">
                                <i class="fas fa-pause mr-1"></i>停止
                            </button>
                            <button id="resetBtn" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded flex-1">
                                <i class="fas fa-redo mr-1"></i>リセット
                            </button>
                        </div>
                        <button id="shuffleBtn" class="w-full mt-2 bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded">
                            <i class="fas fa-random mr-1"></i>シャッフル
                        </button>
                    </div>

                    <!-- Info -->
                    <div class="text-xs text-gray-400 pt-4 border-t border-gray-600">
                        <div>推定像数: <span id="imageCount">6</span></div>
                        <div>平均反射回数: <span id="avgReflections">3.2</span></div>
                        <div>FPS: <span id="fps">60</span></div>
                    </div>
                </div>
            </div>

            <!-- Kaleidoscope Display -->
            <div class="lg:col-span-3">
                <div class="kaleidoscope-container rounded-lg p-4">
                    <canvas id="kaleidoscopeCanvas" class="w-full border-2 border-gray-600 rounded" width="800" height="600"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedKaleidoscope {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isRunning = false;
                this.isPaused = false;
                
                // Core properties
                this.mirrorCount = 3;
                this.angles = [60, 60, 60];
                this.reflectance = 0.90;
                this.roughness = 0.02;
                this.objectCount = 80;
                this.speed = 1.0;
                this.wetMode = false;
                this.viscosity = 0.1;
                this.polarization = false;
                this.polarAngle = 0;
                this.dispersion = false;
                
                // Objects
                this.objects = [];
                
                // Performance tracking
                this.fps = 0;
                this.lastTime = 0;
                this.frameCount = 0;
                
                this.initializeCanvas();
                this.createObjects();
                this.setupEventListeners();
                this.start();
            }
            
            initializeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                
                this.centerX = rect.width / 2;
                this.centerY = rect.height / 2;
                this.radius = Math.min(rect.width, rect.height) * 0.4;
            }
            
            createObjects() {
                this.objects = [];
                const colors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24',
                    '#f0932b', '#eb4d4b', '#6c5ce7', '#fd79a8',
                    '#00b894', '#fdcb6e', '#e84393', '#0984e3'
                ];
                
                for (let i = 0; i < this.objectCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.sqrt(Math.random()) * (this.radius * 0.8);
                    
                    this.objects.push({
                        x: Math.cos(angle) * distance,
                        y: Math.sin(angle) * distance,
                        vx: (Math.random() - 0.5) * 60,
                        vy: (Math.random() - 0.5) * 60,
                        size: 2 + Math.random() * 6,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        shape: Math.random() > 0.5 ? 'circle' : 'polygon',
                        sides: 3 + Math.floor(Math.random() * 5),
                        rotation: Math.random() * Math.PI * 2,
                        angularVelocity: (Math.random() - 0.5) * 5,
                        mass: 1 + Math.random() * 3,
                        age: 0
                    });
                }
            }
            
            updateObjects(deltaTime) {
                this.objects.forEach(obj => {
                    obj.age += deltaTime;
                    
                    // Physics calculations
                    if (this.wetMode) {
                        // Wet physics: viscosity, buoyancy
                        obj.vx *= (1 - this.viscosity * deltaTime);
                        obj.vy *= (1 - this.viscosity * deltaTime);
                        
                        // Add some floating motion
                        obj.vy += Math.sin(obj.age * 2) * 5 * deltaTime;
                    } else {
                        // Dry physics: gravity, air resistance
                        obj.vy += 20 * deltaTime; // gravity
                        obj.vx *= 0.999;
                        obj.vy *= 0.999;
                    }
                    
                    // Update position
                    obj.x += obj.vx * deltaTime * this.speed;
                    obj.y += obj.vy * deltaTime * this.speed;
                    
                    // Update rotation
                    obj.rotation += obj.angularVelocity * deltaTime * this.speed;
                    
                    // Boundary collision
                    const distance = Math.sqrt(obj.x * obj.x + obj.y * obj.y);
                    if (distance > this.radius - obj.size) {
                        const nx = obj.x / distance;
                        const ny = obj.y / distance;
                        
                        // Reflect velocity
                        const dot = obj.vx * nx + obj.vy * ny;
                        obj.vx -= 2 * dot * nx * 0.8;
                        obj.vy -= 2 * dot * ny * 0.8;
                        
                        // Push back inside
                        const overlap = distance + obj.size - this.radius;
                        obj.x -= nx * overlap;
                        obj.y -= ny * overlap;
                    }
                });
            }
            
            renderMirrorSector() {
                // Create off-screen canvas for sector
                const sectorCanvas = document.createElement('canvas');
                const sectorCtx = sectorCanvas.getContext('2d');
                sectorCanvas.width = this.radius * 2;
                sectorCanvas.height = this.radius * 2;
                
                const centerX = this.radius;
                const centerY = this.radius;
                
                // Calculate sector angle
                const sectorAngle = (2 * Math.PI) / this.mirrorCount;
                
                // Clear and set clip
                sectorCtx.save();
                sectorCtx.translate(centerX, centerY);
                sectorCtx.beginPath();
                sectorCtx.moveTo(0, 0);
                sectorCtx.arc(0, 0, this.radius, -sectorAngle/2, sectorAngle/2);
                sectorCtx.closePath();
                sectorCtx.clip();
                
                // Add background gradient
                const gradient = sectorCtx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                gradient.addColorStop(0, 'rgba(255,255,255,0.05)');
                gradient.addColorStop(1, 'rgba(255,255,255,0.01)');
                sectorCtx.fillStyle = gradient;
                sectorCtx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
                
                // Draw objects
                this.objects.forEach(obj => {
                    sectorCtx.save();
                    sectorCtx.translate(obj.x, obj.y);
                    sectorCtx.rotate(obj.rotation);
                    
                    // Apply optical effects
                    if (this.polarization) {
                        const polarEffect = Math.cos((this.polarAngle + obj.rotation) * Math.PI / 180);
                        sectorCtx.globalAlpha = Math.abs(polarEffect) * 0.8 + 0.2;
                    }
                    
                    if (this.dispersion) {
                        // Simple chromatic aberration effect
                        const offset = obj.size * 0.2;
                        sectorCtx.shadowColor = obj.color;
                        sectorCtx.shadowBlur = offset;
                        sectorCtx.shadowOffsetX = Math.sin(obj.age) * offset;
                        sectorCtx.shadowOffsetY = Math.cos(obj.age) * offset;
                    }
                    
                    sectorCtx.fillStyle = obj.color;
                    
                    if (obj.shape === 'circle') {
                        sectorCtx.beginPath();
                        sectorCtx.arc(0, 0, obj.size, 0, Math.PI * 2);
                        sectorCtx.fill();
                    } else {
                        sectorCtx.beginPath();
                        for (let i = 0; i < obj.sides; i++) {
                            const angle = (i / obj.sides) * Math.PI * 2;
                            const x = Math.cos(angle) * obj.size;
                            const y = Math.sin(angle) * obj.size;
                            if (i === 0) sectorCtx.moveTo(x, y);
                            else sectorCtx.lineTo(x, y);
                        }
                        sectorCtx.closePath();
                        sectorCtx.fill();
                    }
                    
                    sectorCtx.restore();
                });
                
                sectorCtx.restore();
                return sectorCanvas;
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#0f1419';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render sector
                const sectorCanvas = this.renderMirrorSector();
                
                this.ctx.save();
                this.ctx.translate(this.centerX, this.centerY);
                
                // Create circular mask
                this.ctx.beginPath();
                this.ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                this.ctx.clip();
                
                // Render each mirror reflection
                const sectorAngle = (2 * Math.PI) / this.mirrorCount;
                for (let i = 0; i < this.mirrorCount; i++) {
                    this.ctx.save();
                    this.ctx.rotate(i * sectorAngle);
                    
                    // Apply reflectance-based dimming
                    const reflectionLoss = Math.pow(this.reflectance, i);
                    this.ctx.globalAlpha = reflectionLoss;
                    
                    // Add surface roughness scattering
                    if (this.roughness > 0.01) {
                        const scatter = (Math.random() - 0.5) * this.roughness * 10;
                        this.ctx.rotate(scatter);
                    }
                    
                    // Flip alternate sectors for mirror effect
                    if (i % 2 === 1) {
                        this.ctx.scale(1, -1);
                    }
                    
                    this.ctx.drawImage(sectorCanvas, -this.radius, -this.radius);
                    this.ctx.restore();
                }
                
                this.ctx.restore();
                
                // Draw border
                this.ctx.strokeStyle = '#4a5568';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Update info
                this.updateInfo();
            }
            
            updateInfo() {
                document.getElementById('imageCount').textContent = this.mirrorCount;
                document.getElementById('avgReflections').textContent = (this.mirrorCount * 0.5).toFixed(1);
                document.getElementById('fps').textContent = Math.round(this.fps);
            }
            
            setupEventListeners() {
                // Mirror count
                document.getElementById('mirrorCount').addEventListener('change', (e) => {
                    this.mirrorCount = parseInt(e.target.value);
                    this.updateAngleControls();
                });
                
                // Material preset
                document.getElementById('materialPreset').addEventListener('change', (e) => {
                    const presets = {
                        silver: 0.975,
                        aluminum: 0.90,
                        plastic: 0.85,
                        custom: this.reflectance
                    };
                    if (e.target.value !== 'custom') {
                        this.reflectance = presets[e.target.value];
                        document.getElementById('reflectance').value = this.reflectance;
                        document.getElementById('reflectanceValue').textContent = this.reflectance.toFixed(3);
                    }
                });
                
                // Sliders
                this.setupSlider('reflectance', 'reflectanceValue', (v) => this.reflectance = parseFloat(v));
                this.setupSlider('roughness', 'roughnessValue', (v) => this.roughness = parseFloat(v));
                this.setupSlider('objectCount', 'objectCountValue', (v) => {
                    this.objectCount = parseInt(v);
                    this.createObjects();
                });
                this.setupSlider('speed', 'speedValue', (v) => this.speed = parseFloat(v));
                this.setupSlider('viscosity', 'viscosityValue', (v) => this.viscosity = parseFloat(v));
                this.setupSlider('polarAngle', 'polarAngleValue', (v) => this.polarAngle = parseFloat(v));
                
                // Checkboxes
                document.getElementById('wetMode').addEventListener('change', (e) => {
                    this.wetMode = e.target.checked;
                    document.getElementById('viscosityControl').style.display = this.wetMode ? 'block' : 'none';
                });
                
                document.getElementById('polarization').addEventListener('change', (e) => {
                    this.polarization = e.target.checked;
                    document.getElementById('polarizationControls').style.display = this.polarization ? 'block' : 'none';
                });
                
                document.getElementById('dispersion').addEventListener('change', (e) => {
                    this.dispersion = e.target.checked;
                });
                
                // Buttons
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.isPaused = !this.isPaused;
                    document.getElementById('pauseBtn').innerHTML = this.isPaused 
                        ? '<i class="fas fa-play mr-1"></i>再生' 
                        : '<i class="fas fa-pause mr-1"></i>停止';
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.createObjects();
                });
                
                document.getElementById('shuffleBtn').addEventListener('click', () => {
                    this.objects.forEach(obj => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.sqrt(Math.random()) * (this.radius * 0.8);
                        obj.x = Math.cos(angle) * distance;
                        obj.y = Math.sin(angle) * distance;
                        obj.vx = (Math.random() - 0.5) * 60;
                        obj.vy = (Math.random() - 0.5) * 60;
                    });
                });
                
                // Presets
                document.querySelectorAll('[data-preset]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.applyPreset(e.target.dataset.preset);
                    });
                });
            }
            
            setupSlider(sliderId, valueId, callback) {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(valueId);
                
                slider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    valueDisplay.textContent = parseFloat(value).toFixed(sliderId.includes('Count') ? 0 : 
                                                                       sliderId === 'speed' ? 1 : 
                                                                       sliderId.includes('Angle') ? 0 : 3);
                    callback(value);
                });
            }
            
            updateAngleControls() {
                const container = document.getElementById('angleControls');
                container.innerHTML = '';
                
                for (let i = 0; i < this.mirrorCount; i++) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <label class="block text-sm font-medium mb-1">
                            <span class="mirror-indicator bg-blue-400"></span>
                            ミラー${i + 1}: <span id="angle${i}Value">60</span>°
                        </label>
                        <input type="range" id="angle${i}" class="slider w-full" 
                               min="15" max="120" step="5" value="60">
                    `;
                    container.appendChild(div);
                    
                    const slider = div.querySelector(`#angle${i}`);
                    const display = div.querySelector(`#angle${i}Value`);
                    
                    slider.addEventListener('input', (e) => {
                        this.angles[i] = parseInt(e.target.value);
                        display.textContent = e.target.value;
                    });
                }
            }
            
            applyPreset(preset) {
                const presets = {
                    hexagon: { mirrors: 3, angles: [60, 60, 60], objects: 60, wet: false },
                    square: { mirrors: 4, angles: [45, 45, 45, 45], objects: 80, wet: false },
                    kaleidoscope: { mirrors: 6, angles: [30, 30, 30, 30, 30, 30], objects: 100, wet: false },
                    organic: { mirrors: 2, angles: [72, 72], objects: 120, wet: true }
                };
                
                const config = presets[preset];
                if (config) {
                    document.getElementById('mirrorCount').value = config.mirrors;
                    document.getElementById('objectCount').value = config.objects;
                    document.getElementById('wetMode').checked = config.wet;
                    
                    this.mirrorCount = config.mirrors;
                    this.angles = [...config.angles];
                    this.objectCount = config.objects;
                    this.wetMode = config.wet;
                    
                    document.getElementById('objectCountValue').textContent = config.objects;
                    document.getElementById('viscosityControl').style.display = config.wet ? 'block' : 'none';
                    
                    this.updateAngleControls();
                    this.createObjects();
                }
            }
            
            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.updateAngleControls();
                this.animate();
            }
            
            animate(currentTime = 0) {
                if (!this.isRunning) return;
                
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                // Calculate FPS
                this.frameCount++;
                if (this.frameCount % 60 === 0) {
                    this.fps = 1 / deltaTime;
                }
                
                if (!this.isPaused) {
                    this.updateObjects(Math.min(deltaTime, 0.016)); // Cap at ~60fps
                }
                
                this.render();
                requestAnimationFrame((time) => this.animate(time));
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('kaleidoscopeCanvas');
            new AdvancedKaleidoscope(canvas);
            
            // Handle window resize
            window.addEventListener('resize', () => {
                // Reinitialize canvas if needed
                setTimeout(() => {
                    const rect = canvas.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = rect.width * dpr;
                    canvas.height = rect.height * dpr;
                }, 100);
            });
        });
    </script>
</body>
</html>
    <script id="html_badge_script1">
        window.__genspark_remove_badge_link = "https://www.genspark.ai/api/html_badge/" +
            "remove_badge?token=To%2FBnjzloZ3UfQdcSaYfDmnoSVEJnwMyytAPZ%2BJa2DAxzgRQVnxJEubTR6BrjSSwV%2FvpNtDZ46gYufxIHMKzg%2Fw96SDNQicrWJ62AIeLWDFv%2FYb1%2Fbo7DCZzeVwWSGJXLv4bfnC%2B1%2FylIpCjOFbaf9IkDs2QmYD98LuMZU5aQsu5C6sXHFycX2pAfYyW%2FaLrFaZC1oIX1Gp5V4jHKZBw0NzUszZHcYJkDMii4wXIryFjYCAHDehOaHIIUFoQnD9NyKfDtDsGq%2FWzgr3FT4i2D0OS6cQbv9Z7zTIAfteA49aFxEPJIa4I%2FIklV%2BPfb0iokzOfc%2FCO3BxcUTX0E9kLUPjKx%2FXTpBd4DOOQZA3EKj5jigo0E5a0am6QiVMje7mFKHH4adPGdA37eESMenzahty9%2FUNZwzwpfhXKFzhYsVX5Vb9wLSYuE0bDU4VUn6x0AXt5mGDqxut1mDElVNQhRPqDLMPIz9%2BL0o1PSVbdoevnWvtfVB3DAoyC2cpEecoo2%2Fj5szuN74JFFcGNZNGDUN2KFyQaFNlVnlmT79orTt8%3D";
        window.__genspark_locale = "ja-JP";
        window.__genspark_token = "To/BnjzloZ3UfQdcSaYfDmnoSVEJnwMyytAPZ+Ja2DAxzgRQVnxJEubTR6BrjSSwV/vpNtDZ46gYufxIHMKzg/w96SDNQicrWJ62AIeLWDFv/Yb1/bo7DCZzeVwWSGJXLv4bfnC+1/ylIpCjOFbaf9IkDs2QmYD98LuMZU5aQsu5C6sXHFycX2pAfYyW/aLrFaZC1oIX1Gp5V4jHKZBw0NzUszZHcYJkDMii4wXIryFjYCAHDehOaHIIUFoQnD9NyKfDtDsGq/Wzgr3FT4i2D0OS6cQbv9Z7zTIAfteA49aFxEPJIa4I/IklV+Pfb0iokzOfc/CO3BxcUTX0E9kLUPjKx/XTpBd4DOOQZA3EKj5jigo0E5a0am6QiVMje7mFKHH4adPGdA37eESMenzahty9/UNZwzwpfhXKFzhYsVX5Vb9wLSYuE0bDU4VUn6x0AXt5mGDqxut1mDElVNQhRPqDLMPIz9+L0o1PSVbdoevnWvtfVB3DAoyC2cpEecoo2/j5szuN74JFFcGNZNGDUN2KFyQaFNlVnlmT79orTt8=";
    </script>
    
    <script id="html_notice_dialog_script" src="https://www.genspark.ai/notice_dialog.js"></script>
    
